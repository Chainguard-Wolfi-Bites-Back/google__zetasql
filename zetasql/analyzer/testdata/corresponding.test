# CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
UNION ALL CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING and CORRESPONDING BY for set operations are not supported [at 2:11]
UNION ALL CORRESPONDING
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

# CORRESPONDING in multiple operations.
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
UNION ALL
SELECT 2
UNION ALL CORRESPONDING
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING and CORRESPONDING BY for set operations are not supported [at 4:11]
UNION ALL CORRESPONDING
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: Different column match modes cannot be used in the same query without using parentheses for grouping [at 4:11]
UNION ALL CORRESPONDING
          ^
==

# CORRESPONDING BY
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
UNION ALL CORRESPONDING BY (a, b, c)
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING and CORRESPONDING BY for set operations are not supported [at 2:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: CORRESPONDING BY is not implemented [at 2:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
==

# CORRESPONDING BY in multiple operations
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
UNION ALL
SELECT 2
UNION ALL CORRESPONDING BY (a, b, c)
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING and CORRESPONDING BY for set operations are not supported [at 4:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: CORRESPONDING BY is not implemented [at 4:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
==

# STRICT without CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
UNION DISTINCT STRICT
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:16]
UNION DISTINCT STRICT
               ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: STRICT in set operations cannot be used without CORRESPONDING [at 2:16]
UNION DISTINCT STRICT
               ^
==

# STRICT without CORRESPONDING in multiple set operations
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
UNION DISTINCT
SELECT 2
UNION DISTINCT STRICT
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 4:16]
UNION DISTINCT STRICT
               ^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: STRICT in set operations cannot be used without CORRESPONDING [at 4:16]
UNION DISTINCT STRICT
               ^
==

# FULL without CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
FULL EXCEPT ALL
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:1]
FULL EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: FULL in set operations cannot be used without CORRESPONDING [at 2:1]
FULL EXCEPT ALL
^
==

# FULL without CORRESPONDING in multiple operations
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
EXCEPT ALL
SELECT 2
FULL EXCEPT ALL
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 4:1]
FULL EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: FULL in set operations cannot be used without CORRESPONDING [at 4:1]
FULL EXCEPT ALL
^
==

# LEFT without CORRESPONDING
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
LEFT EXCEPT ALL
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 2:1]
LEFT EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: LEFT in set operations cannot be used without CORRESPONDING [at 2:1]
LEFT EXCEPT ALL
^
==

# LEFT without CORRESPONDING in multiple set operations
[language_features={{|V_1_4_CORRESPONDING}}]
SELECT 1
EXCEPT ALL
SELECT 2
LEFT EXCEPT ALL
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: Column propagation mode (FULL/LEFT/STRICT) for set operations are not supported [at 4:1]
LEFT EXCEPT ALL
^
--
ALTERNATION GROUP: V_1_4_CORRESPONDING
--
ERROR: LEFT in set operations cannot be used without CORRESPONDING [at 4:1]
LEFT EXCEPT ALL
^
==

[default language_features=V_1_4_CORRESPONDING]
# FULL and LEFT not implemented.
SELECT 1
{{FULL|LEFT}} UNION ALL CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: FULL
--
ERROR: FULL mode for set operations is not implemented [at 3:1]
FULL UNION ALL CORRESPONDING
^
--
ALTERNATION GROUP: LEFT
--
ERROR: LEFT mode for set operations is not implemented [at 3:1]
LEFT UNION ALL CORRESPONDING
^
==

# STRICT not implemented.
SELECT 1
UNION ALL STRICT CORRESPONDING
SELECT 2
--
ERROR: STRICT mode for set operations is not implemented [at 2:11]
UNION ALL STRICT CORRESPONDING
          ^
==

# CORRESPONDING: same columns at same index.
SELECT 1 AS col1, 2 AS col2
EXCEPT DISTINCT CORRESPONDING
SELECT 3 AS col1, 4 AS col2
--
QueryStmt
+-output_column_list=
| +-$except_distinct.col1#5 AS col1 [INT64]
| +-$except_distinct.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[col1#5, col2#6]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$except_distinct1.[col1#1, col2#2]
    | | |   +-expr_list=
    | | |   | +-col1#1 := Literal(type=INT64, value=1)
    | | |   | +-col2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$except_distinct1.[col1#1, col2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_distinct2.[col1#3, col2#4]
    |   |   +-expr_list=
    |   |   | +-col1#3 := Literal(type=INT64, value=3)
    |   |   | +-col2#4 := Literal(type=INT64, value=4)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$except_distinct2.[col1#3, col2#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: same columns at different index, the output column order is
# determined by the first query.
SELECT 1 AS col1, 2 AS col2
INTERSECT ALL CORRESPONDING
SELECT 3 AS col2, 4 AS col1
--
QueryStmt
+-output_column_list=
| +-$intersect_all.col1#5 AS col1 [INT64]
| +-$intersect_all.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[col1#5, col2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[col1#1, col2#2]
    | | |   +-expr_list=
    | | |   | +-col1#1 := Literal(type=INT64, value=1)
    | | |   | +-col2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[col1#1, col2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all2.[col2#3, col1#4]
    |   |   +-expr_list=
    |   |   | +-col2#3 := Literal(type=INT64, value=3)
    |   |   | +-col1#4 := Literal(type=INT64, value=4)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$intersect_all2.[col1#4, col2#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: extra columns are ignored.
SELECT 1 AS col, 2 AS extra_col_1
UNION ALL CORRESPONDING
SELECT 3 AS extra_col_2, 4 AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#5 AS col [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[col#1, extra_col_1#2]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=INT64, value=1)
    | | |   | +-extra_col_1#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[extra_col_2#3, col#4]
    |   |   +-expr_list=
    |   |   | +-extra_col_2#3 := Literal(type=INT64, value=3)
    |   |   | +-col#4 := Literal(type=INT64, value=4)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: column name comparison is case-insensitive.
SELECT 1 AS cOl1, 2 AS CoL2
INTERSECT ALL CORRESPONDING
SELECT 3 AS Col2, 4 AS cOL1
--
QueryStmt
+-output_column_list=
| +-$intersect_all.cOl1#5 AS cOl1 [INT64]
| +-$intersect_all.CoL2#6 AS CoL2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[cOl1#5, CoL2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[cOl1#1, CoL2#2]
    | | |   +-expr_list=
    | | |   | +-cOl1#1 := Literal(type=INT64, value=1)
    | | |   | +-CoL2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[cOl1#1, CoL2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all2.[Col2#3, cOL1#4]
    |   |   +-expr_list=
    |   |   | +-Col2#3 := Literal(type=INT64, value=3)
    |   |   | +-cOL1#4 := Literal(type=INT64, value=4)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$intersect_all2.[cOL1#4, Col2#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: duplicate columns are not allowed.
SELECT 1 AS col1, 2 AS col2
EXCEPT DISTINCT CORRESPONDING
SELECT 3 AS col2, 4 AS col2
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: col2 in query 2 [at 3:1]
SELECT 3 AS col2, 4 AS col2
^
==

# CORRESPONDING: duplicate columns are not allowed (case-insensitive).
SELECT 1 AS col1, 2 AS COL1
EXCEPT DISTINCT CORRESPONDING
SELECT 3 AS col2, 4 AS col3
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: COL1 in query 1 [at 1:1]
SELECT 1 AS col1, 2 AS COL1
^
==

# CORRESPONDING: duplicate columns in SELECT *.
SELECT *, 1 AS c
FROM (
  SELECT 1 AS a, 1 AS a
)
UNION ALL CORRESPONDING
SELECT 1 AS c
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS c
^
==

# CORRESPONDING: duplicate columns with SELECT *: '*' expands to multiple
# columns, one of which has the same name as a column outside '*'. Error
# location should be the start of the query.
SELECT *, 1 AS a
FROM (
  SELECT 1 AS a, 2 AS b
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS a
^
==

# CORRESPONDING: no common columns.
SELECT 1 AS col1, 2 AS col2
UNION DISTINCT CORRESPONDING
SELECT 3 AS col3, 4 AS col4
--
ERROR: Queries of the set operation using CORRESPONDING do not have any columns in common [at 2:1]
UNION DISTINCT CORRESPONDING
^
==

# CORRESPONDING: value table not allowed.
SELECT AS STRUCT 1 a, 2 b
UNION ALL CORRESPONDING
SELECT AS STRUCT 3 c, 4 d
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 1 [at 2:1]
UNION ALL CORRESPONDING
^
==

# CORRESPONDING: anonymous columns are not allowed.
SELECT 1, 2
UNION ALL CORRESPONDING
SELECT 4, 5
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1, 2
^
==

# CORRESPONDING: SELECT * with anonymous columns. Error is reported at the start
# of the query because we cannot always find the ast location of a resolved
# column.
SELECT 1, *
FROM (
  SELECT 1 AS a, 2 AS b
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1, *
^
==

# CORRESPONDING: SELECT * with anonymous columns.
SELECT *, 1
FROM (
  SELECT 1 AS a
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 2 [at 1:1]
SELECT *, 1
^
==

# CORRESPONDING: SELECT * expands to containing anonymous columns.
# Error is reported at the start of the query.
SELECT *, 1 AS a
FROM (
  SELECT 1, 2 AS c
)
UNION ALL CORRESPONDING
SELECT 1 AS a
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT *, 1 AS a
^
==

# CORRESPONDING: same column with different alias within a query is allowed.
SELECT `int32` AS col1, `int32` AS col2
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float` AS col2, `float` AS col1
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#37 AS col1 [DOUBLE]
| +-$union_all.col2#38 AS col2 [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#37, col2#38]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1_cast.[int32#39, int32#40]
    | | |   +-expr_list=
    | | |   | +-int32#39 :=
    | | |   | | +-Cast(INT32 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   | +-int32#40 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=$union_all1_cast.[int32#39, int32#40]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2_cast.[float#41, float#42]
    |   |   +-expr_list=
    |   |   | +-float#41 :=
    |   |   | | +-Cast(FLOAT -> DOUBLE)
    |   |   | |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#26)
    |   |   | +-float#42 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#26)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[float#26, float#26]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.float#26], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=$union_all2_cast.[float#41, float#42]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: same column with and without alias.
SELECT `int32` AS col, `int32` FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float`, `float` AS col FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col#37 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#37]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.int32#38]
    | | |   +-expr_list=
    | | |   | +-int32#38 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$union_all1_cast.int32#38]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.float#39]
    |   |   +-expr_list=
    |   |   | +-float#39 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#26)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[float#26, float#26]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.float#26], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=[$union_all2_cast.float#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Nested operations.
SELECT * FROM
(
  SELECT 'abc' AS col, 'bcd' AS extra_col
  UNION ALL CORRESPONDING
  SELECT 'def' AS col
)
--
QueryStmt
+-output_column_list=
| +-$union_all.col#4 AS col [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.col#4]
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.col#4]
        +-op_type=UNION_ALL
        +-input_item_list=
        | +-SetOperationItem
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$union_all1.[col#1, extra_col#2]
        | | |   +-expr_list=
        | | |   | +-col#1 := Literal(type=STRING, value="abc")
        | | |   | +-extra_col#2 := Literal(type=STRING, value="bcd")
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-output_column_list=[$union_all1.col#1]
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$union_all2.col#3]
        |   |   +-expr_list=
        |   |   | +-col#3 := Literal(type=STRING, value="def")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-output_column_list=[$union_all2.col#3]
        +-column_match_mode=CORRESPONDING
        +-column_propagation_mode=INNER
==

# CORRESPONDING: no common supertype.
select 1 AS col
union all CORRESPONDING
select 'abc' AS col
--
ERROR: Column col in UNION ALL has incompatible types: INT64, STRING [at 3:1]
select 'abc' AS col
^
==

# CORRESPONDING: different (non-literal) types coerce to a common supertype.
# We wrap an extra ProjectScan around the first query to coerce it to double.
SELECT 'a' a, 1 + 1 v1
UNION ALL CORRESPONDING
SELECT 'a' b, 1.0 + 1.0 v1
--
QueryStmt
+-output_column_list=
| +-$union_all.v1#5 AS v1 [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.v1#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.v1#6]
    | | |   +-expr_list=
    | | |   | +-v1#6 :=
    | | |   |   +-Cast(INT64 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT64, column=$union_all1.v1#2)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[a#1, v1#2]
    | | |       +-expr_list=
    | | |       | +-a#1 := Literal(type=STRING, value="a")
    | | |       | +-v1#2 :=
    | | |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | | |       |     +-Literal(type=INT64, value=1)
    | | |       |     +-Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.v1#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[b#3, v1#4]
    |   |   +-expr_list=
    |   |   | +-b#3 := Literal(type=STRING, value="a")
    |   |   | +-v1#4 :=
    |   |   |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |     +-Literal(type=DOUBLE, value=1)
    |   |   |     +-Literal(type=DOUBLE, value=1)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.v1#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Extra columns are omitted from table scan.
SELECT `uint32`, `float`
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `uint32`, `json`
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `json`, `uint32`
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.uint32#55 AS uint32 [UINT32]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.uint32#55]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[uint32#3, float#8]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[uint32#3, float#8], table=SimpleTypes, column_index_list=[2, 7])
    | | +-output_column_list=[SimpleTypes.uint32#3]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[uint32#21, json#36]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[uint32#21, json#36], table=SimpleTypes, column_index_list=[2, 17])
    | | +-output_column_list=[SimpleTypes.uint32#21]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[json#54, uint32#39]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=SimpleTypes.[uint32#39, json#54], table=SimpleTypes, column_index_list=[2, 17])
    |   +-output_column_list=[SimpleTypes.uint32#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation with CORRESPONDING as an input item for another
# set operation: CORREPSPONDING in BY_POSITION.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL CORRESPONDING
  SELECT int64, int32 FROM SimpleTypes
)
UNION ALL
SELECT int32, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#57 AS int32 [INT32]
| +-$union_all.int64#58 AS int64 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int32#57, int64#58]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-SetOperationScan
      | |   +-column_list=$union_all.[int32#37, int64#38]
      | |   +-op_type=UNION_ALL
      | |   +-input_item_list=
      | |   | +-SetOperationItem
      | |   | | +-scan=
      | |   | | | +-ProjectScan
      | |   | | |   +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
      | |   | | |   +-input_scan=
      | |   | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
      | |   | | +-output_column_list=SimpleTypes.[int32#1, int64#2]
      | |   | +-SetOperationItem
      | |   |   +-scan=
      | |   |   | +-ProjectScan
      | |   |   |   +-column_list=SimpleTypes.[int64#20, int32#19]
      | |   |   |   +-input_scan=
      | |   |   |     +-TableScan(column_list=SimpleTypes.[int32#19, int64#20], table=SimpleTypes, column_index_list=[0, 1])
      | |   |   +-output_column_list=SimpleTypes.[int32#19, int64#20]
      | |   +-column_match_mode=CORRESPONDING
      | |   +-column_propagation_mode=INNER
      | +-output_column_list=$union_all.[int32#37, int64#38]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypes.int32#39, $union_all2_cast.int32#59]
        |   +-expr_list=
        |   | +-int32#59 :=
        |   |   +-Cast(INT32 -> INT64)
        |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#39)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypes.[int32#39, int32#39]
        |       +-input_scan=
        |         +-TableScan(column_list=[SimpleTypes.int32#39], table=SimpleTypes, column_index_list=[0])
        +-output_column_list=[SimpleTypes.int32#39, $union_all2_cast.int32#59]
==

# CORRESPONDING: Set operation with CORRESPONDING as an input item for another
# set operation: CORREPSPONDING in CORRESPONDING.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL CORRESPONDING
  SELECT int64, int32 FROM SimpleTypes
)
UNION ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#57 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.int32#57]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$union_all.[int32#37, int64#38]
    | | |   +-op_type=UNION_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
    | | |   | | |   +-input_scan=
    | | |   | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
    | | |   | | +-output_column_list=SimpleTypes.[int32#1, int64#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=SimpleTypes.[int64#20, int32#19]
    | | |   |   |   +-input_scan=
    | | |   |   |     +-TableScan(column_list=SimpleTypes.[int32#19, int64#20], table=SimpleTypes, column_index_list=[0, 1])
    | | |   |   +-output_column_list=SimpleTypes.[int32#19, int64#20]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=INNER
    | | +-output_column_list=[$union_all.int32#37]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int32#39, float#46]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=SimpleTypes.[int32#39, float#46], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[SimpleTypes.int32#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation as an input item for another set operation:
# BY_POSITION in CORRESPONDING.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL
  SELECT int64, int32, int64 FROM SimpleTypes
)
UNION ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#62 AS int32 [INT64]
| +-$union_all.float#63 AS float [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int32#62, float#63]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$union_all.[int32#37, int64#38, float#39]
    | | |   +-op_type=UNION_ALL
    | | |   +-input_item_list=
    | | |     +-SetOperationItem
    | | |     | +-scan=
    | | |     | | +-ProjectScan
    | | |     | |   +-column_list=[$union_all1_cast.int32#40, SimpleTypes.int64#2, $union_all1_cast.float#41]
    | | |     | |   +-expr_list=
    | | |     | |   | +-int32#40 :=
    | | |     | |   | | +-Cast(INT32 -> INT64)
    | | |     | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |     | |   | +-float#41 :=
    | | |     | |   |   +-Cast(FLOAT -> DOUBLE)
    | | |     | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |     | |   +-input_scan=
    | | |     | |     +-ProjectScan
    | | |     | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
    | | |     | |       +-input_scan=
    | | |     | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
    | | |     | +-output_column_list=[$union_all1_cast.int32#40, SimpleTypes.int64#2, $union_all1_cast.float#41]
    | | |     +-SetOperationItem
    | | |       +-scan=
    | | |       | +-ProjectScan
    | | |       |   +-column_list=[SimpleTypes.int64#20, $union_all2_cast.int32#42, $union_all2_cast.int64#43]
    | | |       |   +-expr_list=
    | | |       |   | +-int32#42 :=
    | | |       |   | | +-Cast(INT32 -> INT64)
    | | |       |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#19)
    | | |       |   | +-int64#43 :=
    | | |       |   |   +-Cast(INT64 -> DOUBLE)
    | | |       |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#20)
    | | |       |   +-input_scan=
    | | |       |     +-ProjectScan
    | | |       |       +-column_list=SimpleTypes.[int64#20, int32#19, int64#20]
    | | |       |       +-input_scan=
    | | |       |         +-TableScan(column_list=SimpleTypes.[int32#19, int64#20], table=SimpleTypes, column_index_list=[0, 1])
    | | |       +-output_column_list=[SimpleTypes.int64#20, $union_all2_cast.int32#42, $union_all2_cast.int64#43]
    | | +-output_column_list=$union_all.[int32#37, float#39]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2_cast.[int32#64, float#65]
    |   |   +-expr_list=
    |   |   | +-int32#64 :=
    |   |   | | +-Cast(INT32 -> INT64)
    |   |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#44)
    |   |   | +-float#65 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#51)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#44, float#51]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#44, float#51], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=$union_all2_cast.[int32#64, float#65]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: The edge case of SELECT DISTINCT is handled correctly despite
# the missing ProjectScan issue mentioned in b/36095506.
SELECT DISTINCT a AS col1, b AS col2, a AS col3
FROM (
  SELECT 1 AS a, 2 AS b
)
UNION ALL CORRESPONDING
SELECT 1 AS col3, 1 AS col1, 2 AS col2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#8 AS col1 [INT64]
| +-$union_all.col2#9 AS col2 [INT64]
| +-$union_all.col3#10 AS col3 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#8, col2#9, col3#10]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-AggregateScan
    | | |   +-column_list=$distinct.[a#3, b#4]
    | | |   +-input_scan=
    | | |   | +-ProjectScan
    | | |   |   +-column_list=$subquery1.[a#1, b#2]
    | | |   |   +-expr_list=
    | | |   |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   |   +-input_scan=
    | | |   |     +-SingleRowScan
    | | |   +-group_by_list=
    | | |     +-a#3 := ColumnRef(type=INT64, column=$subquery1.a#1)
    | | |     +-b#4 := ColumnRef(type=INT64, column=$subquery1.b#2)
    | | +-output_column_list=$distinct.[a#3, b#4, a#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[col3#5, col1#6, col2#7]
    |   |   +-expr_list=
    |   |   | +-col3#5 := Literal(type=INT64, value=1)
    |   |   | +-col1#6 := Literal(type=INT64, value=1)
    |   |   | +-col2#7 := Literal(type=INT64, value=2)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all2.[col1#6, col2#7, col3#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union two of the same proto and proto + string literal.
select KitchenSink AS col, KitchenSink from TestTable
union all CORRESPONDING
select KitchenSink, "int64_key_1: 1, int64_key_2: 2" AS col from TestTable
--
QueryStmt
+-output_column_list=
| +-$union_all.col#8 AS col [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$union_all.KitchenSink#9 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col#8, KitchenSink#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=TestTable.[KitchenSink#3, KitchenSink#3]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
    | | +-output_column_list=TestTable.[KitchenSink#3, KitchenSink#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#10, TestTable.KitchenSink#6]
    |   |   +-expr_list=
    |   |   | +-col#10 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[TestTable.KitchenSink#6, $union_all2.col#7]
    |   |       +-expr_list=
    |   |       | +-col#7 := Literal(type=STRING, value="int64_key_1: 1, int64_key_2: 2")
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2])
    |   +-output_column_list=[$union_all2_cast.col#10, TestTable.KitchenSink#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union two different protos.
select 1 AS extra_1, KitchenSink.message_with_nulls AS col from TestTable
union all CORRESPONDING
select KitchenSink.nested_value AS col, 2 AS extra_2 from TestTable
--
ERROR: Column col in UNION ALL has incompatible types: zetasql_test__.MessageWithNulls, zetasql_test__.KitchenSinkPB.Nested [at 3:1]
select KitchenSink.nested_value AS col, 2 AS extra_2 from TestTable
^
==

# CORRESPONDING: Incompatible types in multiple operations.
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select cast(5 as int64) AS key union all CORRESPONDING
select cast(5 as int32) AS key union all CORRESPONDING
select 5 AS key union all CORRESPONDING
select value AS key from KeyValue union all CORRESPONDING
select key from KeyValue
--
ERROR: Column key in UNION ALL has incompatible types: INT64, INT64, INT64, INT64, INT64, INT32, INT64, STRING, INT64 [at 2:1]
select key from KeyValue union all CORRESPONDING
^
==

# CORRESPONDING: Multiple columns, some of which have to get widened in either direction.
select `int32` AS col1, `uint32` AS col2, `string` AS col3 from SimpleTypes s1
union all CORRESPONDING
select `string` AS col3, `int32` AS col2, `int64` AS col1, from SimpleTypes s2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#37 AS col1 [INT64]
| +-$union_all.col2#38 AS col2 [INT64]
| +-$union_all.col3#39 AS col3 [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#37, col2#38, col3#39]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.int32#40, $union_all1_cast.uint32#41, SimpleTypes.string#5]
    | | |   +-expr_list=
    | | |   | +-int32#40 :=
    | | |   | | +-Cast(INT32 -> INT64)
    | | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   | +-uint32#41 :=
    | | |   |   +-Cast(UINT32 -> INT64)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, uint32#3, string#5]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3, string#5], table=SimpleTypes, column_index_list=[0, 2, 4], alias="s1")
    | | +-output_column_list=[$union_all1_cast.int32#40, $union_all1_cast.uint32#41, SimpleTypes.string#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.int64#20, $union_all2_cast.int32#42, SimpleTypes.string#23]
    |   |   +-expr_list=
    |   |   | +-int32#42 :=
    |   |   |   +-Cast(INT32 -> INT64)
    |   |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#19)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[string#23, int32#19, int64#20]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#19, int64#20, string#23], table=SimpleTypes, column_index_list=[0, 1, 4], alias="s2")
    |   +-output_column_list=[SimpleTypes.int64#20, $union_all2_cast.int32#42, SimpleTypes.string#23]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Nested operations output column names are ordered according to the first query.
SELECT *
FROM (
  SELECT 1 AS col1, 2 AS col2
  UNION ALL CORRESPONDING
  SELECT 1 AS col2, 2 AS col1
)
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#5 AS col1 [INT64]
| +-$union_all.col2#6 AS col2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$union_all.[col1#5, col2#6]
    +-input_scan=
      +-SetOperationScan
        +-column_list=$union_all.[col1#5, col2#6]
        +-op_type=UNION_ALL
        +-input_item_list=
        | +-SetOperationItem
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$union_all1.[col1#1, col2#2]
        | | |   +-expr_list=
        | | |   | +-col1#1 := Literal(type=INT64, value=1)
        | | |   | +-col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-output_column_list=$union_all1.[col1#1, col2#2]
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$union_all2.[col2#3, col1#4]
        |   |   +-expr_list=
        |   |   | +-col2#3 := Literal(type=INT64, value=1)
        |   |   | +-col1#4 := Literal(type=INT64, value=2)
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-output_column_list=$union_all2.[col1#4, col2#3]
        +-column_match_mode=CORRESPONDING
        +-column_propagation_mode=INNER
==

# CORRESPONDING: coercion with NULL.
SELECT NULL AS timestamp FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT timestamp FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.timestamp#38 AS timestamp [TIMESTAMP]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.timestamp#38]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.timestamp#39]
    | | |   +-expr_list=
    | | |   | +-timestamp#39 := Literal(type=TIMESTAMP, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.timestamp#19]
    | | |       +-expr_list=
    | | |       | +-timestamp#19 := Literal(type=INT64, value=NULL)
    | | |       +-input_scan=
    | | |         +-TableScan(table=SimpleTypes)
    | | +-output_column_list=[$union_all1_cast.timestamp#39]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.timestamp#34]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[SimpleTypes.timestamp#34], table=SimpleTypes, column_index_list=[14])
    |   +-output_column_list=[SimpleTypes.timestamp#34]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two identical structs works.
# Field names are determined from the first leg of the union.
select (select AS STRUCT 1 a, 2 bbB) AS col
union all CORRESPONDING
select (select AS STRUCT 3 a, 4 Bbb) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<a INT64, bbB INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<a INT64, bbB INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<a INT64, bbB INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.bbB#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[a#1, bbB#2]
    | | |   |             +-expr_list=
    | | |   |             | +-a#1 := Literal(type=INT64, value=1)
    | | |   |             | +-bbB#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#8]
    |   |   +-expr_list=
    |   |   | +-col#8 :=
    |   |   |   +-SubqueryExpr
    |   |   |     +-type=STRUCT<a INT64, Bbb INT64>
    |   |   |     +-subquery_type=SCALAR
    |   |   |     +-subquery=
    |   |   |       +-ProjectScan
    |   |   |         +-column_list=[$make_struct.$struct#7]
    |   |   |         +-expr_list=
    |   |   |         | +-$struct#7 :=
    |   |   |         |   +-MakeStruct
    |   |   |         |     +-type=STRUCT<a INT64, Bbb INT64>
    |   |   |         |     +-field_list=
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.Bbb#6)
    |   |   |         +-input_scan=
    |   |   |           +-ProjectScan
    |   |   |             +-column_list=$expr_subquery.[a#5, Bbb#6]
    |   |   |             +-expr_list=
    |   |   |             | +-a#5 := Literal(type=INT64, value=3)
    |   |   |             | +-Bbb#6 := Literal(type=INT64, value=4)
    |   |   |             +-input_scan=
    |   |   |               +-SingleRowScan
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#8]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two STRUCTs with different column/field names.
# Note that the second input to the union has the STRUCT field casted to a STRUCT
# with the same field names as the STRUCT from the first input to the union.
select (select AS STRUCT 1 a, 2 b) AS foo
union all CORRESPONDING
select (select AS STRUCT 3 b, 4 c) as foo
--
QueryStmt
+-output_column_list=
| +-$union_all.foo#9 AS foo [STRUCT<a INT64, b INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.foo#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.foo#4]
    | | |   +-expr_list=
    | | |   | +-foo#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<a INT64, b INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<a INT64, b INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[a#1, b#2]
    | | |   |             +-expr_list=
    | | |   |             | +-a#1 := Literal(type=INT64, value=1)
    | | |   |             | +-b#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.foo#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.foo#10]
    |   |   +-expr_list=
    |   |   | +-foo#10 :=
    |   |   |   +-Cast(STRUCT<b INT64, c INT64> -> STRUCT<a INT64, b INT64>)
    |   |   |     +-ColumnRef(type=STRUCT<b INT64, c INT64>, column=$union_all2.foo#8)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.foo#8]
    |   |       +-expr_list=
    |   |       | +-foo#8 :=
    |   |       |   +-SubqueryExpr
    |   |       |     +-type=STRUCT<b INT64, c INT64>
    |   |       |     +-subquery_type=SCALAR
    |   |       |     +-subquery=
    |   |       |       +-ProjectScan
    |   |       |         +-column_list=[$make_struct.$struct#7]
    |   |       |         +-expr_list=
    |   |       |         | +-$struct#7 :=
    |   |       |         |   +-MakeStruct
    |   |       |         |     +-type=STRUCT<b INT64, c INT64>
    |   |       |         |     +-field_list=
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#5)
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.c#6)
    |   |       |         +-input_scan=
    |   |       |           +-ProjectScan
    |   |       |             +-column_list=$expr_subquery.[b#5, c#6]
    |   |       |             +-expr_list=
    |   |       |             | +-b#5 := Literal(type=INT64, value=3)
    |   |       |             | +-c#6 := Literal(type=INT64, value=4)
    |   |       |             +-input_scan=
    |   |       |               +-SingleRowScan
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.foo#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of a STRUCT value table and non-value table not allowed.
select AS STRUCT 1 a, 2 b
union all CORRESPONDING
select STRUCT<c int64, d int64>(3, 4) as e
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 1 [at 2:1]
union all CORRESPONDING
^
==

# CORRESPONDING: UNION of a non-value table and STRUCT value table not allowed.
select STRUCT<c int64, d int64>(3, 4) as e
union all CORRESPONDING
select AS STRUCT 1 a, 2 b
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 2 [at 2:1]
union all CORRESPONDING
^
==

# CORRESPONDING: Union of two coercible structs types.
select (select AS STRUCT 1 a, 2 b) AS col
union all CORRESPONDING
select (select AS STRUCT 3 a, 4.5 b) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<a INT64, b DOUBLE>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.col#10]
    | | |   +-expr_list=
    | | |   | +-col#10 :=
    | | |   |   +-Cast(STRUCT<a INT64, b INT64> -> STRUCT<a INT64, b DOUBLE>)
    | | |   |     +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$union_all1.col#4)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.col#4]
    | | |       +-expr_list=
    | | |       | +-col#4 :=
    | | |       |   +-SubqueryExpr
    | | |       |     +-type=STRUCT<a INT64, b INT64>
    | | |       |     +-subquery_type=SCALAR
    | | |       |     +-subquery=
    | | |       |       +-ProjectScan
    | | |       |         +-column_list=[$make_struct.$struct#3]
    | | |       |         +-expr_list=
    | | |       |         | +-$struct#3 :=
    | | |       |         |   +-MakeStruct
    | | |       |         |     +-type=STRUCT<a INT64, b INT64>
    | | |       |         |     +-field_list=
    | | |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
    | | |       |         +-input_scan=
    | | |       |           +-ProjectScan
    | | |       |             +-column_list=$expr_subquery.[a#1, b#2]
    | | |       |             +-expr_list=
    | | |       |             | +-a#1 := Literal(type=INT64, value=1)
    | | |       |             | +-b#2 := Literal(type=INT64, value=2)
    | | |       |             +-input_scan=
    | | |       |               +-SingleRowScan
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.col#10]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#8]
    |   |   +-expr_list=
    |   |   | +-col#8 :=
    |   |   |   +-SubqueryExpr
    |   |   |     +-type=STRUCT<a INT64, b DOUBLE>
    |   |   |     +-subquery_type=SCALAR
    |   |   |     +-subquery=
    |   |   |       +-ProjectScan
    |   |   |         +-column_list=[$make_struct.$struct#7]
    |   |   |         +-expr_list=
    |   |   |         | +-$struct#7 :=
    |   |   |         |   +-MakeStruct
    |   |   |         |     +-type=STRUCT<a INT64, b DOUBLE>
    |   |   |         |     +-field_list=
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |   |         |       +-ColumnRef(type=DOUBLE, column=$expr_subquery.b#6)
    |   |   |         +-input_scan=
    |   |   |           +-ProjectScan
    |   |   |             +-column_list=$expr_subquery.[a#5, b#6]
    |   |   |             +-expr_list=
    |   |   |             | +-a#5 := Literal(type=INT64, value=3)
    |   |   |             | +-b#6 := Literal(type=DOUBLE, value=4.5)
    |   |   |             +-input_scan=
    |   |   |               +-SingleRowScan
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#8]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two non-coercible struct types.
select (select AS STRUCT cast(1 as uint64) a, 2 b) AS col
union all CORRESPONDING
select (select AS STRUCT cast(1 as int32) a, 2 b) AS col
--
ERROR: Column col in UNION ALL has incompatible types: STRUCT<a UINT64, b INT64>, STRUCT<a INT32, b INT64> [at 3:1]
select (select AS STRUCT cast(1 as int32) a, 2 b) AS col
^
==

# CORRESPONDING: Only field names of the first struct will determine the field names of
# supertyped struct.
select (select AS STRUCT 1, 2) AS col
union all CORRESPONDING
select (select AS STRUCT 3 a, 4 b) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<INT64, INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<INT64, INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<INT64, INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col1#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col2#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[$col1#1, $col2#2]
    | | |   |             +-expr_list=
    | | |   |             | +-$col1#1 := Literal(type=INT64, value=1)
    | | |   |             | +-$col2#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#10]
    |   |   +-expr_list=
    |   |   | +-col#10 :=
    |   |   |   +-Cast(STRUCT<a INT64, b INT64> -> STRUCT<INT64, INT64>)
    |   |   |     +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$union_all2.col#8)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.col#8]
    |   |       +-expr_list=
    |   |       | +-col#8 :=
    |   |       |   +-SubqueryExpr
    |   |       |     +-type=STRUCT<a INT64, b INT64>
    |   |       |     +-subquery_type=SCALAR
    |   |       |     +-subquery=
    |   |       |       +-ProjectScan
    |   |       |         +-column_list=[$make_struct.$struct#7]
    |   |       |         +-expr_list=
    |   |       |         | +-$struct#7 :=
    |   |       |         |   +-MakeStruct
    |   |       |         |     +-type=STRUCT<a INT64, b INT64>
    |   |       |         |     +-field_list=
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#6)
    |   |       |         +-input_scan=
    |   |       |           +-ProjectScan
    |   |       |             +-column_list=$expr_subquery.[a#5, b#6]
    |   |       |             +-expr_list=
    |   |       |             | +-a#5 := Literal(type=INT64, value=3)
    |   |       |             | +-b#6 := Literal(type=INT64, value=4)
    |   |       |             +-input_scan=
    |   |       |               +-SingleRowScan
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.col#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of struct parameters.
(select struct(1, "abc") AS col)
union all CORRESPONDING
(select @test_param_struct AS col limit 1)
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [STRUCT<INT32, STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 := Literal(type=STRUCT<INT32, STRING>, value={1, "abc"})
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.col#1]
    | | |       +-expr_list=
    | | |       | +-col#1 := Literal(type=STRUCT<INT64, STRING>, value={1, "abc"})
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#5]
    |   |   +-expr_list=
    |   |   | +-col#5 :=
    |   |   |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<INT32, STRING>)
    |   |   |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$union_all2.col#2)
    |   |   +-input_scan=
    |   |     +-LimitOffsetScan
    |   |       +-column_list=[$union_all2.col#2]
    |   |       +-input_scan=
    |   |       | +-ProjectScan
    |   |       |   +-column_list=[$union_all2.col#2]
    |   |       |   +-expr_list=
    |   |       |   | +-col#2 := Parameter(type=STRUCT<a INT32, b STRING>, name="test_param_struct")
    |   |       |   +-input_scan=
    |   |       |     +-SingleRowScan
    |   |       +-limit=
    |   |         +-Literal(type=INT64, value=1)
    |   +-output_column_list=[$union_all2_cast.col#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: with a group by.
select `uint64` from SimpleTypes
union all CORRESPONDING
select CAST(1 AS UINT64) as `uint64` from SimpleTypes
group by `uint64`
--
QueryStmt
+-output_column_list=
| +-$union_all.uint64#38 AS uint64 [UINT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.uint64#38]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint64#4]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[SimpleTypes.uint64#4], table=SimpleTypes, column_index_list=[3])
    | | +-output_column_list=[SimpleTypes.uint64#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$groupby.uint64#37]
    |   |   +-input_scan=
    |   |     +-AggregateScan
    |   |       +-column_list=[$groupby.uint64#37]
    |   |       +-input_scan=
    |   |       | +-TableScan(table=SimpleTypes)
    |   |       +-group_by_list=
    |   |         +-uint64#37 := Literal(type=UINT64, value=1, has_explicit_type=TRUE)
    |   +-output_column_list=[$groupby.uint64#37]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Type coercing in multiple operations of columns from table scans.
SELECT `uint32` AS col
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `int32` AS col
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float` AS col
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col#55 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#55]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.uint32#56]
    | | |   +-expr_list=
    | | |   | +-uint32#56 :=
    | | |   |   +-Cast(UINT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.uint32#3]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2])
    | | +-output_column_list=[$union_all1_cast.uint32#56]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all2_cast.int32#57]
    | | |   +-expr_list=
    | | |   | +-int32#57 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#19)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.int32#19]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#19], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$union_all2_cast.int32#57]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3_cast.float#58]
    |   |   +-expr_list=
    |   |   | +-float#58 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#44)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.float#44]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.float#44], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=[$union_all3_cast.float#58]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: nested set operations with type coercing.
select `uint32` AS col from SimpleTypes s1
UNION ALL CORRESPONDING
(select `int32` AS col from SimpleTypes s2
 INTERSECT ALL CORRESPONDING
 (select `float` AS col from SimpleTypes s3 EXCEPT ALL CORRESPONDING select 1 AS col));
--
QueryStmt
+-output_column_list=
| +-$union_all.col#61 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#61]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.uint32#62]
    | | |   +-expr_list=
    | | |   | +-uint32#62 :=
    | | |   |   +-Cast(UINT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.uint32#3]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2], alias="s1")
    | | +-output_column_list=[$union_all1_cast.uint32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=[$intersect_all.col#58]
    |   |   +-op_type=INTERSECT_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=[$intersect_all1_cast.int32#59]
    |   |   | | |   +-expr_list=
    |   |   | | |   | +-int32#59 :=
    |   |   | | |   |   +-Cast(INT32 -> DOUBLE)
    |   |   | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#19)
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=[SimpleTypes.int32#19]
    |   |   | | |       +-input_scan=
    |   |   | | |         +-TableScan(column_list=[SimpleTypes.int32#19], table=SimpleTypes, column_index_list=[0], alias="s2")
    |   |   | | +-output_column_list=[$intersect_all1_cast.int32#59]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=[$intersect_all2_cast.col#60]
    |   |   |   |   +-expr_list=
    |   |   |   |   | +-col#60 :=
    |   |   |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |   |   |     +-ColumnRef(type=FLOAT, column=$except_all.col#56)
    |   |   |   |   +-input_scan=
    |   |   |   |     +-SetOperationScan
    |   |   |   |       +-column_list=[$except_all.col#56]
    |   |   |   |       +-op_type=EXCEPT_ALL
    |   |   |   |       +-input_item_list=
    |   |   |   |       | +-SetOperationItem
    |   |   |   |       | | +-scan=
    |   |   |   |       | | | +-ProjectScan
    |   |   |   |       | | |   +-column_list=[SimpleTypes.float#44]
    |   |   |   |       | | |   +-input_scan=
    |   |   |   |       | | |     +-TableScan(column_list=[SimpleTypes.float#44], table=SimpleTypes, column_index_list=[7], alias="s3")
    |   |   |   |       | | +-output_column_list=[SimpleTypes.float#44]
    |   |   |   |       | +-SetOperationItem
    |   |   |   |       |   +-scan=
    |   |   |   |       |   | +-ProjectScan
    |   |   |   |       |   |   +-column_list=[$except_all2_cast.col#57]
    |   |   |   |       |   |   +-expr_list=
    |   |   |   |       |   |   | +-col#57 := Literal(type=FLOAT, value=1)
    |   |   |   |       |   |   +-input_scan=
    |   |   |   |       |   |     +-ProjectScan
    |   |   |   |       |   |       +-column_list=[$except_all2.col#55]
    |   |   |   |       |   |       +-expr_list=
    |   |   |   |       |   |       | +-col#55 := Literal(type=INT64, value=1)
    |   |   |   |       |   |       +-input_scan=
    |   |   |   |       |   |         +-SingleRowScan
    |   |   |   |       |   +-output_column_list=[$except_all2_cast.col#57]
    |   |   |   |       +-column_match_mode=CORRESPONDING
    |   |   |   |       +-column_propagation_mode=INNER
    |   |   |   +-output_column_list=[$intersect_all2_cast.col#60]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=[$intersect_all.col#58]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION ALL CORRESPONDING with anonymous STRUCT.
select (1, 1) AS col union all CORRESPONDING select (1, 1) AS col;
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [STRUCT<INT64, INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#2]
    |   |   +-expr_list=
    |   |   | +-col#2 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of arrays.
select [1, 1] AS col union all CORRESPONDING select [2, 3, 4] AS col;
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [ARRAY<INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=ARRAY<INT64>, value=[1, 1])
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#2]
    |   |   +-expr_list=
    |   |   | +-col#2 := Literal(type=ARRAY<INT64>, value=[2, 3, 4])
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Subqueries with SELECT *.
select "abc" c1, cast(1 as int64) c2
union all CORRESPONDING
select * from (
  select "def" c1, cast(1 as int32) c2
)
--
QueryStmt
+-output_column_list=
| +-$union_all.c1#5 AS c1 [STRING]
| +-$union_all.c2#6 AS c2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[c1#5, c2#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[c1#1, c2#2]
    | | |   +-expr_list=
    | | |   | +-c1#1 := Literal(type=STRING, value="abc")
    | | |   | +-c2#2 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[c1#1, c2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.c1#3, $union_all2_cast.c2#7]
    |   |   +-expr_list=
    |   |   | +-c2#7 :=
    |   |   |   +-Cast(INT32 -> INT64)
    |   |   |     +-ColumnRef(type=INT32, column=$subquery1.c2#4)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$subquery1.[c1#3, c2#4]
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$subquery1.[c1#3, c2#4]
    |   |           +-expr_list=
    |   |           | +-c1#3 := Literal(type=STRING, value="def")
    |   |           | +-c2#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$subquery1.c1#3, $union_all2_cast.c2#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation with hint.
select 1 AS col
UNION @{ key = 5 } ALL CORRESPONDING
select 2 AS col
UNION ALL CORRESPONDING
select 3 AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#4 AS col [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#4]
    +-hint_list=
    | +-key := Literal(type=INT64, value=5)
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=INT64, value=1)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all2.col#2]
    | | |   +-expr_list=
    | | |   | +-col#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all2.col#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3.col#3]
    |   |   +-expr_list=
    |   |   | +-col#3 := Literal(type=INT64, value=3)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all3.col#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==
